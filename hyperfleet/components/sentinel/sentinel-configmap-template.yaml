# ============================================================================
# HyperFleet Message Broker ConfigMap Template
# ============================================================================
#
# This ConfigMap is created and managed by the broker component.
# Adapters read this ConfigMap to connect to the message broker without
# knowing the broker type or connection details.
#
# Usage:
# 1. Broker component detects environment and chooses broker type
# 2. Broker component deploys broker infrastructure
# 3. Broker component creates this ConfigMap with appropriate values
# 4. Adapters mount this ConfigMap as environment variables
# 5. Adapter framework reads BROKER_TYPE and connects automatically

---
# ============================================================================
# Template: Google Cloud Pub/Sub
# ============================================================================
# Use this template when deploying on GCP or using Google Pub/Sub
apiVersion: v1
kind: ConfigMap
metadata:
  name: hyperfleet-message-sentinel-config
  namespace: hyperfleet-system
  labels:
    app.kubernetes.io/name: hyperfleet-message-sentinel
    app.kubernetes.io/component: message-sentinel
    app.kubernetes.io/managed-by: hyperfleet-message-sentinel-controller
data:
  # Broker type identifier (framework uses this to select the right client)
  BROKER_TYPE: "pubsub"
  
  # Google Cloud project ID containing the Pub/Sub subscription
  BROKER_PROJECT_ID: "your-gcp-project-id"
  
  # Sentinel type identifier (framework uses this to select the right client)
  SENTINEL_TYPE: "example"

---
# ============================================================================
# Template: AWS SQS
# ============================================================================
# Use this template when deploying on AWS or using AWS SQS
apiVersion: v1
kind: ConfigMap
metadata:
  name: hyperfleet-message-sentinel-cluster-events-config
  namespace: hyperfleet-system
  labels:
    app.kubernetes.io/name: hyperfleet-message-sentinel
    app.kubernetes.io/component: message-sentinel
    app.kubernetes.io/managed-by: hyperfleet-message-sentinel-controller
data:
  # Broker type identifier
  BROKER_TYPE: "awsSqs"
  
  # AWS region where the SQS queue exists
  BROKER_REGION: "us-east-1"
  
  # Full SQS queue URL
  BROKER_QUEUE_URL: "https://sqs.us-east-1.amazonaws.com/123456789012/hyperfleet-cluster-events"

  # Sentinel type identifier (framework uses this to select the right client)
  SENTINEL_TYPE: "cluster"
---
# ============================================================================
# Template: RabbitMQ
# ============================================================================
# Use this template when deploying on-premises or using RabbitMQ
apiVersion: v1
kind: ConfigMap
metadata:
  name: hyperfleet-message-sentinel-nodepool-events-config
  namespace: hyperfleet-system
  labels:
    app.kubernetes.io/name: hyperfleet-message-sentinel-nodepool-events
    app.kubernetes.io/component: message-sentinel
    app.kubernetes.io/managed-by: hyperfleet-message-sentinel-controller
data:
  # Broker type identifier
  BROKER_TYPE: "rabbitmq"
  
  # RabbitMQ connection details
  BROKER_HOST: "rabbitmq.hyperfleet-system.svc.local"
  BROKER_PORT: "5672"
  BROKER_VHOST: "/"
  
  # Queue and exchange configuration
  BROKER_EXCHANGE: "hyperfleet-nodepool-events"
  BROKER_EXCHANGE_TYPE: "fanout"
  SENTINEL_TYPE: "nodepool"

---
# ============================================================================
# Customization Guide
# ============================================================================
#
# This ConfigMap is created and managed by the broker component.
# The Sentinel operator reads this ConfigMap to publish events to the broker.
#
# IMPORTANT: You typically do NOT need to manually create or edit this ConfigMap.
# The broker component will automatically:
#   1. Detect your environment (GCP/AWS/on-premises)
#   2. Deploy the appropriate broker infrastructure
#   3. Create this ConfigMap with the correct values
#
# When to customize:
#
# Scenario 1: Override broker type for testing
#   - Copy the appropriate template above
#   - Change BROKER_TYPE to test different broker implementations
#   - Apply manually: kubectl apply -f sentinel-config-test.yaml
#   - Restart Sentinel pods to pick up new configuration
#
# Scenario 2: Multi-region deployment
#   - For GCP: Update BROKER_PROJECT_ID for each region's project
#   - For AWS: Update BROKER_REGION and BROKER_QUEUE_URL for regional queues
#   - For RabbitMQ: Update BROKER_HOST to point to regional RabbitMQ cluster
#
# Scenario 3: Development/local testing
#   - Use RabbitMQ template (easiest to run locally)
#   - Set BROKER_HOST to "localhost" or "rabbitmq.hyperfleet-system.svc.cluster.local"
#   - Use default queue names and exchanges
#
# Example for production GCP (multi-region):
#   Region us-east: BROKER_PROJECT_ID = "hyperfleet-prod-us"
#   Region eu-west: BROKER_PROJECT_ID = "hyperfleet-prod-eu"
#
# Example for production AWS:
#   Region us-east-1: BROKER_REGION = "us-east-1", BROKER_QUEUE_URL = "https://sqs.us-east-1..."
#   Region eu-west-1: BROKER_REGION = "eu-west-1", BROKER_QUEUE_URL = "https://sqs.eu-west-1..."

---
# ============================================================================
# Field Reference
# ============================================================================
#
# Required fields (all brokers):
#   BROKER_TYPE: Broker type identifier (pubsub, awsSqs, rabbitmq, kafka)
#
# Google Pub/Sub specific:
#   BROKER_PROJECT_ID:       GCP project ID
#   BROKER_SUBSCRIPTION_ID:  Pub/Sub subscription name
#
# AWS SQS specific:
#   BROKER_REGION:           AWS region (e.g., us-east-1)
#   BROKER_QUEUE_URL:        Full SQS queue URL
#   BROKER_WAIT_TIME:        Long polling wait time (optional)
#   BROKER_VISIBILITY_TIMEOUT: Message visibility timeout (optional)
#
# RabbitMQ specific:
#   BROKER_HOST:             RabbitMQ hostname
#   BROKER_PORT:             RabbitMQ port (default: 5672)
#   BROKER_VHOST:            Virtual host (default: /)
#   BROKER_QUEUE_NAME:       Queue to consume from
#   BROKER_EXCHANGE:         Exchange name
#   BROKER_EXCHANGE_TYPE:    Exchange type (topic, direct, fanout, headers)
#   BROKER_ROUTING_KEY:      Routing key pattern (for topic exchanges)
#   BROKER_PREFETCH_COUNT:   QoS prefetch count (optional)
#
# Note: All fields are strings in ConfigMap. The Sentinel operator will
#       parse them to appropriate types (int, duration, etc.)

---
# ============================================================================
# How Sentinel Component Uses This Template
# ============================================================================
#
# The broker component provides a unified MessageBroker interface that
# the Sentinel operator uses to publish reconciliation events.
#
# MessageBroker Interface:
#
#   type MessageBroker interface {
#       // Publish sends a message to the specified topic/exchange
#       Publish(ctx context.Context, topic string, message []byte) error
#       
#       // Close cleanup broker resources
#       Close() error
#   }
#
# Sentinel operator workflow:
#
# 1. Load configuration from environment (populated from this ConfigMap):
#    config := loadConfig()  // Reads BROKER_TYPE, BROKER_PROJECT_ID, etc.
#
# 2. Create broker client:
#    broker, err := NewBroker(config.Broker)
#    if err != nil {
#        log.Fatal(err)
#    }
#    defer broker.Close()
#
# 3. Start reconciliation loop:
#    for {
#        // Poll HyperFleet API for resources
#        clusters := fetchClustersWithShardFilter(config.ShardSelector)
#        
#        for _, cluster := range clusters {
#            // Check if reconciliation is needed based on max age
#            if shouldReconcile(cluster, config.MaxAgeNotReady, config.MaxAgeReady) {
#                // Create CloudEvent
#                event := createCloudEvent(cluster)
#                
#                // Publish to broker
#                err := broker.Publish(ctx, "cluster-events", event)
#                if err != nil {
#                    log.Error("Failed to publish event", err)
#                }
#            }
#        }
#        
#        // Wait for next poll interval
#        time.Sleep(config.PollInterval)
#    }
#
# The Sentinel doesn't need to know which broker implementation is being used.
# The NewBroker function reads BROKER_TYPE from config and returns the
# appropriate implementation. All broker-specific logic is handled internally.

